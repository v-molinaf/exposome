# Optional generic preliminaries:
graphics.off() # This closes all of R's graphics windows.
rm(list=ls())  # Careful! This clears all of R's memory!
#------------------------------------------------------------------------------- 

# Load rjags library and the wiener module
library(runjags)
library(rjags)
library(lme4)
library(magrittr)
library(ggplot2)
library(readxl)
library(dplyr)
library(tidyr)
library(openxlsx)
library(ggsignif)

setwd("~/GitHub/football-graphs/Carvajal_Tesis")

##carga de datos##
DATA_before <- read.table('DATA/DATA_MSIT_FINAL_SEX_COND.txt',head=T,sep="\t") %>%
  mutate(subID = gsub(" ", "", subID, fixed = TRUE))

DATA_before <- DATA_before %>%
  mutate(Condition_Sex = paste(Condición, Sexo, sep = "_"))

# Calcular los l?mites inferior y superior para eliminar outliers
Q1 <- quantile(DATA_before$rt, 0.25, na.rm = TRUE)
Q3 <- quantile(DATA_before$rt, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1

# Definir los l?mites inferior y superior
lower_limit <- Q1 - 0.5 * IQR
upper_limit <- Q3 + 1 * IQR

# Filtrar los datos para eliminar outliers
DATA_no_outliers <- DATA_before %>%
  filter(rt >= lower_limit & rt <= upper_limit)

# Verificar el rango del eje y
rt_min <- min(DATA_no_outliers$rt, na.rm = TRUE)
rt_max <- max(DATA_no_outliers$rt, na.rm = TRUE)
print(paste("Rango de rt despu?s de eliminar outliers: [", rt_min, ", ", rt_max, "]", sep = ""))


# Asegurarse de que los nombres de las condiciones sean consistentes entre los datos y las comparaciones
DATA_no_outliers$Condicion_Simple <- ifelse(DATA_no_outliers$Condición == "A", "Activo", "Sedentario")

# Calcular el rango del eje y para la nueva comparación
rt_min_simple <- min(DATA_no_outliers$rt, na.rm = TRUE)
rt_max_simple <- max(DATA_no_outliers$rt, na.rm = TRUE)



# Comparaciones entre grupos usando pruebas no param?tricas (Mann-Whitney)
compare_groups <- function(df, group_col, value_col) {
  group_values <- unique(df[[group_col]])
  comparisons <- list()
  for (i in 1:(length(group_values) - 1)) {
    for (j in (i + 1):length(group_values)) {
      g1 <- df %>% filter(!!sym(group_col) == group_values[i]) %>% pull(!!sym(value_col))
      g2 <- df %>% filter(!!sym(group_col) == group_values[j]) %>% pull(!!sym(value_col))
      test_result <- wilcox.test(g1, g2)
      comparisons <- append(comparisons, list(data.frame(
        Group1 = group_values[i],
        Group2 = group_values[j],
        W = test_result$statistic,
        p_value = test_result$p.value
      )))
    }
  }
  do.call(rbind, comparisons)
}
# Funci?n para asignar asteriscos seg?n el nivel de significancia
get_significance <- function(p_value) {
  if (p_value < 0.001) {
    return("***")
  } else if (p_value < 0.01) {
    return("**")
  } else if (p_value < 0.05) {
    return("*")
  } else {
    return("ns")  # A?adir "ns" para no significativo
  }
}


# Comparaciones para rt entre Activos y Sedentarios
comparisons_simple <- compare_groups(DATA_no_outliers, "Condicion_Simple", "rt")

# Aplicar la función para agregar asteriscos según el nivel de significancia
comparisons_simple$significance <- sapply(comparisons_simple$p_value, get_significance)

# Definir la altura para las anotaciones de significancia en este gráfico
comparisons_simple$y_position <- seq(from = rt_max_simple + 50, by = 50, length.out = nrow(comparisons_simple))

# Ver los resultados de las comparaciones
print(comparisons_simple)

# Gráfico de tiempo de reacción por grupo (Activo/Sedentario) sin outliers y con asteriscos de significancia
ggplot(DATA_no_outliers, aes(x = Condicion_Simple, y = rt, fill = Condicion_Simple)) +
  geom_boxplot() +
  labs(title = "Distribution of Reaction Time by Group (Active vs Sedentary)", x = "Group", y = "Reaction Time") +
  theme_minimal() +
  ylim(rt_min_simple, rt_max_simple + 350) +  # Aumentar el rango del eje y para hacer espacio para las anotaciones
  geom_signif(
    comparisons = list(
      c("Activo", "Sedentario")
    ),
    annotations = comparisons_simple$significance,
    y_position = comparisons_simple$y_position,
    tip_length = 0.01
  )

# Cálculo de la D de Cohen entre Activo y Sedentario

# Filtrar los datos para cada grupo
grupo_activo <- DATA_no_outliers %>% filter(Condicion_Simple == "Activo") %>% pull(rt)
grupo_sedentario <- DATA_no_outliers %>% filter(Condicion_Simple == "Sedentario") %>% pull(rt)

# Calcular las medias y desviaciones estándar de cada grupo
mean_activo <- mean(grupo_activo, na.rm = TRUE)
mean_sedentario <- mean(grupo_sedentario, na.rm = TRUE)
sd_activo <- sd(grupo_activo, na.rm = TRUE)
sd_sedentario <- sd(grupo_sedentario, na.rm = TRUE)

# Tamaño de muestra de cada grupo
n_activo <- length(grupo_activo)
n_sedentario <- length(grupo_sedentario)

# Cálculo del SD combinado (SD pooled)
sd_pooled <- sqrt(((n_activo - 1) * sd_activo^2 + (n_sedentario - 1) * sd_sedentario^2) / (n_activo + n_sedentario - 2))

# Cálculo de la D de Cohen
d_cohen <- (mean_activo - mean_sedentario) / sd_pooled

# Mostrar el resultado
print(paste("D de Cohen: ", round(d_cohen, 3)))


# Crear la columna Condition_Sex combinando Condición y Sexo
DATA_no_outliers$Condition_Sex <- paste(DATA_no_outliers$Condición, DATA_no_outliers$Sexo, sep = "_")

# Verifica que la nueva columna se haya creado correctamente
head(DATA_no_outliers)

# Comparaciones para rt sin outliers
comparisons_rt <- compare_groups(DATA_no_outliers, "Condition_Sex", "rt")


# Aplicar la funci?n para agregar asteriscos seg?n el nivel de significancia
comparisons_rt$significance <- sapply(comparisons_rt$p_value, get_significance)

# Definir la altura para las anotaciones de significancia
comparisons_rt$y_position <- seq(from = rt_max + 50, by = 50, length.out = nrow(comparisons_rt))

# Mostrar comparaciones con asteriscos
print(comparisons_rt)

# Gr?fico de tiempo de reacci?n por grupo sin outliers y con asteriscos de significancia
ggplot(DATA_no_outliers, aes(x = Condition_Sex, y = rt, fill = Condition_Sex)) +
  geom_boxplot() +
  labs(title = "Distribution of Reaction Time by Group (Without Outliers)", x = "Group", y = "Reaction Time") +
  theme_minimal() +
  ylim(rt_min, rt_max + 350) +  # Aumentar el rango del eje y para hacer espacio para las anotaciones
  geom_signif(
    comparisons = list(
      c("A_F", "A_M"), c("A_F", "S_F"), c("A_F", "S_M"), 
      c("A_M", "S_F"), c("A_M", "S_M"), c("S_F", "S_M")
    ),
    annotations = comparisons_rt$significance,
    y_position = comparisons_rt$y_position,
    tip_length = 0.01
  )

####TAMAÑO DEL EFECTO####
# Instalar y cargar la librería effsize si no la tienes instalada
if (!require(effsize)) install.packages("effsize")
library(effsize)

# Calcular Cohen's d para cada par de grupos
# Ejemplo para S_M vs A_F
d_SM_AF <- cohen.d(DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "S_M"],
                   DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "A_F"])

# Repetir para las otras comparaciones
d_SM_AM <- cohen.d(DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "S_M"],
                   DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "A_M"])

d_SM_SF <- cohen.d(DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "S_M"],
                   DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "S_F"])

d_AF_AM <- cohen.d(DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "A_F"],
                   DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "A_M"])

d_AF_SF <- cohen.d(DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "A_F"],
                   DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "S_F"])

d_AM_SF <- cohen.d(DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "A_M"],
                   DATA_no_outliers$rt[DATA_no_outliers$Condition_Sex == "S_F"])

# Mostrar los resultados
list(S_M_vs_A_F = d_SM_AF,
     S_M_vs_A_M = d_SM_AM,
     S_M_vs_S_F = d_SM_SF,
     A_F_vs_A_M = d_AF_AM,
     A_F_vs_S_F = d_AF_SF,
     A_M_vs_S_F = d_AM_SF)



########ACCURACY############


# 1. Calcular promedio de accuracy por sujeto y grupo
promedios_acc <- DATA_no_outliers %>%
  group_by(subID, Condicion_Simple) %>%
  summarise(mean_acc = mean(acu, na.rm = TRUE)) %>%
  ungroup()

# 2. Comparación estadística: Mann-Whitney (Wilcoxon)
compare_groups <- function(df, group_col, value_col) {
  group_values <- unique(df[[group_col]])
  comparisons <- list()
  for (i in 1:(length(group_values) - 1)) {
    for (j in (i + 1):length(group_values)) {
      g1 <- df %>% filter(!!sym(group_col) == group_values[i]) %>% pull(!!sym(value_col))
      g2 <- df %>% filter(!!sym(group_col) == group_values[j]) %>% pull(!!sym(value_col))
      test_result <- wilcox.test(g1, g2)
      comparisons <- append(comparisons, list(data.frame(
        Group1 = group_values[i],
        Group2 = group_values[j],
        W = test_result$statistic,
        p_value = test_result$p.value
      )))
    }
  }
  do.call(rbind, comparisons)
}

comparisons_acc <- compare_groups(promedios_acc, "Condicion_Simple", "mean_acc")

# 3. Asignar significancia con asteriscos
get_significance <- function(p_value) {
  if (p_value < 0.001) {
    return("***")
  } else if (p_value < 0.01) {
    return("**")
  } else if (p_value < 0.05) {
    return("*")
  } else {
    return("ns")
  }
}
comparisons_acc$significance <- sapply(comparisons_acc$p_value, get_significance)

# 4. Definir alturas para anotaciones
acc_min <- min(promedios_acc$mean_acc, na.rm = TRUE)
acc_max <- max(promedios_acc$mean_acc, na.rm = TRUE)
comparisons_acc$y_position <- seq(from = acc_max + 0.01, by = 0.01, length.out = nrow(comparisons_acc))

# 5. Gráfico con anotación de significancia
ggplot(promedios_acc, aes(x = Condicion_Simple, y = mean_acc, fill = Condicion_Simple)) +
  geom_boxplot() +
  geom_jitter(width = 0.1, alpha = 0.7) +
  labs(title = "Distribution of Accuracy by Group (Active vs Sedentary)", x = "Group", y = "Mean Accuracy") +
  theme_minimal() +
  ylim(acc_min, acc_max + 0.05) +
  geom_signif(
    comparisons = list(
      c("Activo", "Sedentario")
    ),
    annotations = comparisons_acc$significance,
    y_position = comparisons_acc$y_position,
    tip_length = 0.01
  )


###AN?LISIS DE DIFERENCIA ENTRE EST?MULOS
# Filtrar los datos para est?mulos congruentes e incongruentes
congruent_data <- DATA_before %>% filter(est == 11)
incongruent_data <- DATA_before %>% filter(est == 12)

#Filtrar solo hombres activos
#act_homb_data <- DATA_before %>% filter(Condition_Sex == "A_M")

# Calcular promedios de RT para cada sujeto en cada tipo de est?mulo
avg_rt <- DATA_before %>%
  group_by(subID, est) %>%
  summarise(avg_rt = mean(rt, na.rm = TRUE)) %>%
  spread(est, avg_rt) %>%
  rename(Congruent = `11`, Incongruent = `12`)

# Transformar los datos para el gr?fico de puntos y l?neas
subject_means_long <- avg_rt %>%
  gather(key = "Stimulus", value = "avg_rt", Congruent, Incongruent)

# Box plot para comparar tiempos de reacci?n entre est?mulos congruentes e incongruentes
ggplot(DATA_before, aes(x = as.factor(est), y = rt, fill = as.factor(est))) +
  geom_boxplot() +
  labs(title = "Comparaci?n de Tiempo de Reacci?n entre Est?mulos Congruentes e Incongruentes",
       x = "Est?mulo",
       y = "Tiempo de Reacci?n") +
  scale_fill_discrete(name = "Est?mulo", labels = c("Congruente (11)", "Incongruente (12)")) +
  theme_minimal()

# Incorporar las columnas Sexo y Condición a subject_means_long
subject_means_long <- subject_means_long %>%
  mutate(Sexo = DATA_before$Sexo[match(subID, DATA_before$subID)],
         Condición = DATA_before$Condición[match(subID, DATA_before$subID)])


# Gr?fico de puntos y l?neas conectando a cada sujeto (Hombres y Mujeres)
ggplot(subject_means_long, aes(x = Stimulus, y = avg_rt, group = subID)) +
  geom_point(aes(color = Stimulus), size = 3) +  # Color de los puntos seg?n el est?mulo
  geom_line(color = "gray") +
  labs(title = "Comparison of Reaction Time between Congruent and Incongruent Stimuli by Sex",
       x = "Stimuli",
       y = "Reaction Time") +
  scale_x_discrete(labels = c("Congruent", "Incongruent")) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 20),  # Tama?o del t?tulo
    axis.title.x = element_text(size = 15),  # Tama?o del t?tulo del eje X
    axis.title.y = element_text(size = 15),  # Tama?o del t?tulo del eje Y
    axis.text.x = element_text(size = 15),  # Tama?o de los textos del eje X
    axis.text.y = element_text(size = 15)  # Tama?o de los textos del eje Y
  ) +
  scale_color_manual(values = c("Congruent" = "blue", "Incongruent" = "green"))  # Colores espec?ficos para los est?mulos
geom_signif(comparisons = list(c("Congruent", "Incongruent")),
            map_signif_level = TRUE,
            test = "wilcox.test",
            y_position = max(subject_means_long$avg_rt) * 1.1,  # Ajusta la posici?n vertical de los asteriscos
            tip_length = 0.03, 
            textsize = 6)  # Tama?o del texto de los asteriscos

# Realiza la prueba de Wilcoxon
wilcox_test <- wilcox.test(avg_rt ~ Stimulus, data = subject_means_long)

# Extrae el valor p
p_value <- wilcox_test$p.value
# Calcula las medias y desviaciones est?ndar
means <- subject_means_long %>%
  group_by(Stimulus) %>%
  summarise(mean_rt = mean(avg_rt), sd_rt = sd(avg_rt))

# Calcular accuracy para cada sujeto y est?mulo en DATA_before
accuracy_data <- DATA_before %>%
  group_by(subID, est) %>%
  summarise(accuracy = mean(acu, na.rm = TRUE)) %>%
  spread(est, accuracy) %>%
  rename(Congruent = `11`, Incongruent = `12`) %>%
  gather(key = "Stimulus", value = "accuracy", Congruent, Incongruent)

# A?adir accuracy a subject_means_long
subject_means_long <- subject_means_long %>%
  left_join(accuracy_data, by = c("subID", "Stimulus"))

# Calcular las medias de precisi?n para cada est?mulo
accuracy_means <- subject_means_long %>%
  group_by(Stimulus) %>%
  summarise(mean_accuracy = mean(accuracy, na.rm = TRUE))

# Crear etiquetas de precisi?n para cada est?mulo
accuracy_labels <- paste0("Accuracy: ", round(accuracy_means$mean_accuracy, 2))
names(accuracy_labels) <- accuracy_means$Stimulus

# Gr?fico de puntos y l?neas conectando a cada sujeto (Hombres y Mujeres) con medidas de precisi?n
ggplot(subject_means_long, aes(x = Stimulus, y = avg_rt, group = subID)) +
  geom_point(aes(color = Sexo)) +
  geom_line(color = "gray") +
  labs(title = "Comparison of Reaction Time between Congruent and Incongruent Stimuli by Sex",
       x = "Stimuli",
       y = "Reaction Time") +
  scale_x_discrete(labels = c(Congruent = paste("Congruent\n", accuracy_labels["Congruent"]),
                              Incongruent = paste("Incongruent\n", accuracy_labels["Incongruent"]))) +
  theme_minimal() +
  scale_color_manual(values = c("F" = "lightpink", "M" = "blue"))  # Ajustar colores para sexo

# Crear una columna para ajustar el eje X seg?n el accuracy y el est?mulo
subject_means_long <- subject_means_long %>%
  mutate(x_pos = ifelse(Stimulus == "Congruent", accuracy, 1 + accuracy))


# Filtrar solo los datos del est?mulo congruente
congruent_data <- subject_means_long %>% filter(Stimulus == "Congruent")

# Calcular los rangos globales para accuracy y avg_rt
min_accuracy <- min(c(min(congruent_data$accuracy), min(incongruent_data$accuracy)), na.rm = TRUE)
max_accuracy <- max(c(max(congruent_data$accuracy), max(incongruent_data$accuracy)), na.rm = TRUE)

min_rt <- min(c(min(congruent_data$avg_rt), min(incongruent_data$avg_rt)), na.rm = TRUE)
max_rt <- max(c(max(congruent_data$avg_rt), max(incongruent_data$avg_rt)), na.rm = TRUE)


# Gráfico de accuracy vs reaction time para el estímulo congruente con líneas de tendencia
ggplot(congruent_data, aes(x = accuracy, y = avg_rt, color = Condición)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE, aes(group = Condición), linetype = "solid") +  # Agrega la línea de tendencia
  labs(title = "Accuracy vs Reaction Time for Congruent Stimulus",
       x = "Accuracy",
       y = "Reaction Time") +
  theme_minimal() +
  scale_color_manual(values = c("A" = "orange", "S" = "light blue")) +  # Colores atractivos para Activos y Sedentarios
  coord_cartesian(xlim = c(0.8, 1.0), ylim = c(300, 1000))
# Filtrar solo los datos del est?mulo incongruente
incongruent_data <- subject_means_long %>% filter(Stimulus == "Incongruent" & accuracy >= 0.25)


# Gr?fico de accuracy vs reaction time para el est?mulo incongruente
ggplot(incongruent_data, aes(x = accuracy, y = avg_rt, color = Condición)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE, aes(group = Condición), linetype = "solid") +  # Agrega la línea de tendencia
  labs(title = "Accuracy vs Reaction Time for Incongruent Stimulus",
       x = "Accuracy",
       y = "Reaction Time") +
  theme_minimal() +
  #scale_color_manual(values = c("F" = "purple", "M" = "green"))  # Colores atractivos para F y M
  scale_color_manual(values = c("A" = "orange", "S" = "light blue")) +
  coord_cartesian(xlim = c(0.8, 1.0), ylim = c(300, 1000))

  # Ajustar el modelo lineal con interacción para el estímulo congruente
model_congruent <- lm(avg_rt ~ accuracy * Condición, data = congruent_data)
summary(model_congruent)

# Ajustar el modelo lineal con interacción para el estímulo incongruente
model_incongruent <- lm(avg_rt ~ accuracy * Condición, data = incongruent_data)
summary(model_incongruent)

# Gráfico de avg_rt vs accuracy para el estímulo congruente con líneas de tendencia
ggplot(congruent_data, aes(x = avg_rt, y = accuracy, color = Condición)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE, aes(group = Condición), linetype = "solid") +  # Agrega la línea de tendencia
  labs(title = "Reaction Time vs Accuracy for Congruent Stimulus",
       x = "Reaction Time",
       y = "Accuracy") +
  theme_minimal() +
  scale_color_manual(values = c("A" = "orange", "S" = "light blue"))+  # Colores para Activos y Sedentarios
  coord_cartesian(xlim = c(300, 1000), ylim = c(0.7, 1.0))

# Gráfico de avg_rt vs accuracy para el estímulo incongruente con líneas de tendencia
ggplot(incongruent_data, aes(x = avg_rt, y = accuracy, color = Condición)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE, aes(group = Condición), linetype = "solid") +  # Agrega la línea de tendencia
  labs(title = "Reaction Time vs Accuracy for Incongruent Stimulus",
       x = "Reaction Time",
       y = "Accuracy") +
  theme_minimal() +
  scale_color_manual(values = c("A" = "orange", "S" = "light blue"))+  # Colores para Activos y Sedentarios
  coord_cartesian(xlim = c(300, 1000), ylim = c(0.7, 1.0))


#Ajustar el modelo lineal con interacción para el estímulo congruente con accuracy como dependiente
model_congruent_accuracy <- lm(accuracy ~ avg_rt * Condición, data = congruent_data)
summary(model_congruent_accuracy)

# Ajustar el modelo lineal con interacción para el estímulo incongruente con accuracy como dependiente
model_incongruent_accuracy <- lm(accuracy ~ avg_rt * Condición, data = incongruent_data)
summary(model_incongruent_accuracy)



# Crear una nueva columna combinando Sexo y Condición
subject_means_long <- subject_means_long %>%
  mutate(Sexo_Condición = paste(Sexo, Condición, sep = "_"))

# Filtrar solo los datos del est?mulo congruente e incongruente y eliminar los outliers con accuracy < 0.25
#congruent_data_filtered <- subject_means_long %>% 
incongruent_data_filtered <- subject_means_long %>% 
  #filter(Stimulus == "Congruent")
  filter(Stimulus == "Incongruent" & accuracy >= 0.25)
# Gr?fico de accuracy vs reaction time para el est?mulo incongruente sin outliers
#ggplot(congruent_data_filtered, aes(x = accuracy, y = avg_rt, color = Sexo_Condición)) +
#  geom_point(size = 3) +  # Ajustar el tama?o de los puntos
#  labs(title = "Accuracy vs Reaction Time for Congruent Stimulus",
#       x = "Accuracy",
#       y = "Reaction Time") +
#  theme_minimal() +
#  scale_color_manual(values = c("F_A" = "purple", "F_S" = "orange", "M_A" = "green", "M_S" = "red"))  # Colores para los cuatro grupos

ggplot(incongruent_data_filtered, aes(x = accuracy, y = avg_rt, color = Sexo_Condición)) +
  geom_point(size = 3) +  # Ajustar el tama?o de los puntos
  labs(title = "Accuracy vs Reaction Time for Incongruent Stimulus",
       x = "Accuracy",
       y = "Reaction Time") +
  theme_minimal() +
  scale_color_manual(values = c("F_A" = "purple", "F_S" = "orange", "M_A" = "green", "M_S" = "red"))  # Colores para los cuatro grupos

# Aplicar el test de Wilcoxon
wilcoxon_test <- wilcox.test(subject_means$Congruent, subject_means$Incongruent, paired = TRUE)

# Mostrar el resultado del test de Wilcoxon
print(wilcoxon_test)

library(ggsignif)

# Agregar una columna para el valor p y la significancia en el dataframe de medios
subject_means_long <- subject_means_long %>%
  mutate(significance = ifelse(wilcoxon_test$p.value < 0.001, "***", 
                               ifelse(wilcoxon_test$p.value < 0.01, "**", 
                                      ifelse(wilcoxon_test$p.value < 0.05, "*", "ns"))))

# Gr?fico de puntos y l?neas conectando a cada sujeto con anotaciones de significancia
ggplot(subject_means_long, aes(x = Stimulus, y = avg_rt, group = subID)) +
  geom_point(aes(color = Stimulus)) +
  geom_line(color = "gray") +
  labs(title = "Comparison of Reaction Time between Congruent and Incongruent Stimuli",
       x = "Stimuli",
       y = "Reaction Time") +
  scale_x_discrete(labels = c("Congruente", "Incongruente")) +
  theme_minimal() +
  geom_signif(
    comparisons = list(c("Congruent", "Incongruent")),
    annotations = subject_means_long$significance[1],  # Usamos el primer valor ya que es el mismo para todos
    y_position = max(subject_means_long$avg_rt) + 50,  # Ajustar la posici?n y para la anotaci?n
    tip_length = 0.01
  )




# 1. Filtra solo trials incongruentes
incongruent_trials <- DATA_before %>% filter(est == 12)

# 2. Calcula promedio de RT y accuracy por sujeto y grupo (Condición)
incong_rt <- incongruent_trials %>%
  group_by(subID, Condición) %>%
  summarise(mean_rt = mean(rt, na.rm = TRUE)) %>%
  ungroup()

incong_acc <- incongruent_trials %>%
  group_by(subID, Condición) %>%
  summarise(mean_acc = mean(acu, na.rm = TRUE)) %>%
  ungroup()

# 3. Test de Wilcoxon/Mann-Whitney para comparar Activos vs Sedentarios
wilcox_rt <- wilcox.test(mean_rt ~ Condición, data = incong_rt)
wilcox_acc <- wilcox.test(mean_acc ~ Condición, data = incong_acc)

# 4. Estadísticas descriptivas por grupo (para la tabla del paper)
rt_stats <- incong_rt %>%
  group_by(Condición) %>%
  summarise(
    mean = mean(mean_rt),
    sd = sd(mean_rt),
    min = min(mean_rt),
    max = max(mean_rt)
  )

acc_stats <- incong_acc %>%
  group_by(Condición) %>%
  summarise(
    mean = mean(mean_acc),
    sd = sd(mean_acc),
    min = min(mean_acc),
    max = max(mean_acc)
  )

# 5. Muestra los resultados
cat("Reaction Time (Wilcoxon): W =", wilcox_rt$statistic, ", p =", wilcox_rt$p.value, "\n")
cat("Accuracy (Wilcoxon): W =", wilcox_acc$statistic, ", p =", wilcox_acc$p.value, "\n")

cat("\nReaction Time (ms) by group:\n")
print(rt_stats)
cat("\nAccuracy by group:\n")
print(acc_stats)


########EFECTO DEL CONFLICTO#########

# 1. Promedio de RT y ACC por sujeto y estímulo
subject_means <- DATA_before %>%
  group_by(subID, est) %>%
  summarise(mean_rt = mean(rt, na.rm = TRUE),
            mean_acc = mean(acu, na.rm = TRUE)) %>%
  ungroup()

# 2. Etiquetas claras para estímulo
subject_means <- subject_means %>%
  mutate(Stimulus = ifelse(est == 11, "Congruent", "Incongruent"))

# 3. Hacer formato wide (¡nuevo! usando pivot_wider)
wide_means <- subject_means %>%
  select(subID, Stimulus, mean_rt, mean_acc) %>%
  pivot_wider(names_from = Stimulus, values_from = c(mean_rt, mean_acc))

# 4. Wilcoxon pareado para toda la muestra
wilcox_rt_all <- wilcox.test(wide_means$mean_rt_Congruent, wide_means$mean_rt_Incongruent, paired = TRUE)
wilcox_acc_all <- wilcox.test(wide_means$mean_acc_Congruent, wide_means$mean_acc_Incongruent, paired = TRUE)

cat("All participants:\n")
cat("RT Wilcoxon paired: W =", wilcox_rt_all$statistic, ", p =", wilcox_rt_all$p.value, "\n")
cat("ACC Wilcoxon paired: W =", wilcox_acc_all$statistic, ", p =", wilcox_acc_all$p.value, "\n")

# 5. Analizar por grupo (Activos/Sedentarios)
subject_means <- subject_means %>%
  left_join(DATA_before %>% select(subID, Condición) %>% distinct(), by = "subID")

wide_means_group <- subject_means %>%
  select(subID, Condición, Stimulus, mean_rt, mean_acc) %>%
  pivot_wider(names_from = Stimulus, values_from = c(mean_rt, mean_acc))

# 6. Wilcoxon pareado por grupo
for (grp in unique(wide_means_group$Condición)) {
  datos <- filter(wide_means_group, Condición == grp)
  cat("\nGroup:", grp, "\n")
  cat("RT Wilcoxon paired: W =", wilcox.test(datos$mean_rt_Congruent, datos$mean_rt_Incongruent, paired = TRUE)$statistic,
      ", p =", wilcox.test(datos$mean_rt_Congruent, datos$mean_rt_Incongruent, paired = TRUE)$p.value, "\n")
  cat("ACC Wilcoxon paired: W =", wilcox.test(datos$mean_acc_Congruent, datos$mean_acc_Incongruent, paired = TRUE)$statistic,
      ", p =", wilcox.test(datos$mean_acc_Congruent, datos$mean_acc_Incongruent, paired = TRUE)$p.value, "\n")
}

# 1. Medias y SD por condición de estímulo, sobre TODOS los trials
summary_trials <- DATA_before %>%
  mutate(Stimulus = ifelse(est == 11, "Congruent", "Incongruent")) %>%
  group_by(Stimulus) %>%
  summarise(
    mean_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE),
    mean_acc = mean(acu, na.rm = TRUE),
    sd_acc = sd(acu, na.rm = TRUE)
  )

print(summary_trials)

# 2. Medias y SD por condición de estímulo Y grupo, sobre TODOS los trials
summary_trials_group <- DATA_before %>%
  mutate(Stimulus = ifelse(est == 11, "Congruent", "Incongruent")) %>%
  group_by(Condición, Stimulus) %>%
  summarise(
    mean_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE),
    mean_acc = mean(acu, na.rm = TRUE),
    sd_acc = sd(acu, na.rm = TRUE)
  )

print(summary_trials_group)




#AN?LISIS POR SUBGRUPOS

# Dividir los datos en los 8 grupos distintos
groups <- unique(DATA_before$Condicion_Sexo)

grouped_data <- list()
for (group in groups) {
  grouped_data[[group]] <- DATA_before %>% filter(Condicion_Sexo == group)
}

# Funci?n para calcular promedios y aplicar el test de Wilcoxon
analyze_group <- function(data) {
  subject_means <- data %>%
    group_by(subID, est) %>%
    summarise(avg_rt = mean(rt, na.rm = TRUE)) %>%
    spread(est, avg_rt) %>%
    rename(Congruent = `11`, Incongruent = `12`)
  
  wilcoxon_test <- wilcox.test(subject_means$Congruent, subject_means$Incongruent, paired = TRUE)
  
  subject_means_long <- subject_means %>%
    gather(key = "Stimulus", value = "avg_rt", Congruent, Incongruent) %>%
    mutate(significance = ifelse(wilcoxon_test$p.value < 0.001, "***", 
                                 ifelse(wilcoxon_test$p.value < 0.01, "**", 
                                        ifelse(wilcoxon_test$p.value < 0.05, "*", "ns"))))
  
  return(list(subject_means_long = subject_means_long, wilcoxon_test = wilcoxon_test))
}

results <- list()
for (group in names(grouped_data)) {
  results[[group]] <- analyze_group(grouped_data[[group]])
}

library(gridExtra)

# Funci?n para generar gr?ficos
generate_plot <- function(data, group_name) {
  ggplot(data$subject_means_long, aes(x = Stimulus, y = avg_rt, group = subID)) +
    geom_point(aes(color = Stimulus)) +
    geom_line(color = "gray") +
    labs(title = paste("RT Comparison between Cong and Incong Stimuli", group_name),
         x = "Stimuli",
         y = "Reaction Time") +
    scale_x_discrete(labels = c("Congruent", "Incongruent")) +
    theme_minimal() +
    geom_signif(
      comparisons = list(c("Congruent", "Incongruent")),
      annotations = data$subject_means_long$significance[1],
      y_position = max(data$subject_means_long$avg_rt, na.rm = TRUE) + 50,
      tip_length = 0.01
    )
}

plots <- list()
for (group in names(results)) {
  plots[[group]] <- generate_plot(results[[group]], group)
}

# Mostrar los gr?ficos
grid.arrange(grobs = plots, ncol = 2)

# Crear los grupos generales: Hombre, Mujer, Sedentarios, Activos
general_groups <- list(
  Men = DATA_before %>% filter(Sexo == "M"),
  Women = DATA_before %>% filter(Sexo == "F"),
  Sedentary = DATA_before %>% filter(Condición == "S"),
  Active = DATA_before %>% filter(Condición == "A")
)

# Funci?n para calcular promedios y aplicar el test de Wilcoxon
analyze_group <- function(data) {
  subject_means <- data %>%
    group_by(subID, est) %>%
    summarise(avg_rt = mean(rt, na.rm = TRUE)) %>%
    spread(est, avg_rt) %>%
    rename(Congruent = `11`, Incongruent = `12`)
  
  wilcoxon_test <- wilcox.test(subject_means$Congruent, subject_means$Incongruent, paired = TRUE)
  
  subject_means_long <- subject_means %>%
    gather(key = "Stimulus", value = "avg_rt", Congruent, Incongruent) %>%
    mutate(significance = ifelse(wilcoxon_test$p.value < 0.001, "***", 
                                 ifelse(wilcoxon_test$p.value < 0.01, "**", 
                                        ifelse(wilcoxon_test$p.value < 0.05, "*", "ns"))))
  
  return(list(subject_means_long = subject_means_long, wilcoxon_test = wilcoxon_test))
}

# Calcular promedios y aplicar el test de Wilcoxon para los grupos generales
general_results <- list()
for (group in names(general_groups)) {
  general_results[[group]] <- analyze_group(general_groups[[group]])
}

# Calcular los l?mites comunes del eje Y
calculate_y_limits <- function(data_list) {
  all_values <- unlist(lapply(data_list, function(df) df$subject_means_long$avg_rt))
  return(c(min(all_values, na.rm = TRUE), max(all_values, na.rm = TRUE)))
}

# Obtener los l?mites Y para los gr?ficos
y_limits <- calculate_y_limits(general_results)

# Funci?n para generar gr?ficos con l?mites comunes en el eje Y y color por Sexo o Condición
generate_plot <- function(data, group_name, y_limits, color_variable) {
  # Verificar que las columnas Sexo y Condición est?n presentes
  if (!color_variable %in% names(data$subject_means_long)) {
    stop(paste("La columna", color_variable, "no se encuentra en los datos."))
  }
  
  max_y <- max(data$subject_means_long$avg_rt, na.rm = TRUE)
  
  ggplot(data$subject_means_long, aes(x = Stimulus, y = avg_rt, group = subID, color = !!sym(color_variable))) +
    geom_point() +
    geom_line(aes(group = subID), color = "gray") +
    labs(title = paste("RT Comparison for", group_name),
         x = "Stimuli",
         y = "Reaction Time") +
    scale_x_discrete(labels = c("Congruent", "Incongruent")) +
    theme_minimal() +
    ylim(y_limits) +
    geom_signif(
      comparisons = list(c("Congruent", "Incongruent")),
      annotations = data$subject_means_long$significance[1],
      y_position = max_y + 50,
      tip_length = 0.01
    ) +
    scale_color_manual(values = c("F" = "red", "M" = "blue", "A" = "green", "S" = "purple"))  # Ajustar colores seg?n sexo o Condición
}

# Verificar y agregar las columnas Sexo y Condición en general_results$subject_means
for (group in names(general_results)) {
  if (!"Sexo" %in% names(general_results[[group]]$subject_means)) {
    general_results[[group]]$subject_means$Sexo <- DATA_before$Sexo[match(general_results[[group]]$subject_means$subID, DATA_before$subID)]
  }
  if (!"Condición" %in% names(general_results[[group]]$subject_means)) {
    general_results[[group]]$subject_means$Condición <- DATA_before$Condición[match(general_results[[group]]$subject_means$subID, DATA_before$subID)]
  }
}

# Propagar las columnas Sexo y Condición a general_results$subject_means_long
for (group in names(general_results)) {
  general_results[[group]]$subject_means_long$Sexo <- general_results[[group]]$subject_means$Sexo[match(general_results[[group]]$subject_means_long$subID, general_results[[group]]$subject_means$subID)]
  general_results[[group]]$subject_means_long$Condición <- general_results[[group]]$subject_means$Condición[match(general_results[[group]]$subject_means_long$subID, general_results[[group]]$subject_means$subID)]
}

# Funci?n para generar gr?ficos con l?mites comunes en el eje Y y color por Sexo o Condición
generate_plot <- function(data, group_name, y_limits, color_variable) {
  # Verificar que las columnas Sexo y Condición est?n presentes
  if (!color_variable %in% names(data$subject_means_long)) {
    stop(paste("La columna", color_variable, "no se encuentra en los datos."))
  }
  
  max_y <- max(data$subject_means_long$avg_rt, na.rm = TRUE)
  
  ggplot(data$subject_means_long, aes(x = Stimulus, y = avg_rt, group = subID, color = !!sym(color_variable))) +
    geom_point() +
    geom_line(aes(group = subID), color = "gray") +
    labs(title = paste("RT Comparison for", group_name),
         x = "Stimuli",
         y = "Reaction Time") +
    scale_x_discrete(labels = c("Congruent", "Incongruent")) +
    theme_minimal() +
    ylim(y_limits) +
    geom_signif(
      comparisons = list(c("Congruent", "Incongruent")),
      annotations = data$subject_means_long$significance[1],
      y_position = max_y + 50,
      tip_length = 0.01
    ) +
    scale_color_manual(values = c("F" = "red", "M" = "blue", "A" = "green", "S" = "purple"))  # Ajustar colores seg?n sexo o Condición
}

# Generar gr?ficos para los grupos generales con l?mites comunes en el eje Y y color por sexo
general_plots_sex <- list()
for (group in names(general_results)) {
  general_plots_sex[[group]] <- generate_plot(general_results[[group]], group, y_limits, "Sexo")
}

# Generar gr?ficos para los grupos generales con l?mites comunes en el eje Y y color por Condición
general_plots_condition <- list()
for (group in names(general_results)) {
  general_plots_condition[[group]] <- generate_plot(general_results[[group]], group, y_limits, "Condición")
}

# Mostrar los gr?ficos agrupados por sexo
grid.arrange(grobs = general_plots_sex, ncol = 4)

# Mostrar los gr?ficos agrupados por Condición
grid.arrange(grobs = general_plots_condition, ncol = 4)

###AN?LISIS DE ACCURACY
# Generar datos con precisi?n por tipo de est?mulo y grupo
calculate_accuracy_by_stimulus_and_group <- function(data) {
  data %>%
    group_by(subID, est) %>%
    summarise(accuracy = mean(acu, na.rm = TRUE), .groups = 'drop') %>%
    spread(est, accuracy) %>%
    rename(Congruent = `11`, Incongruent = `12`) %>%
    gather(key = "Stimulus", value = "accuracy", Congruent, Incongruent) %>%
    filter(accuracy >= 0.3)  # Filtrar outliers con accuracy < 0.3
}

# Calcular los rangos comunes para el eje Y
calculate_y_limits <- function(data_list) {
  all_values <- unlist(lapply(data_list, function(df) df$accuracy))
  return(c(min(all_values, na.rm = TRUE), max(all_values, na.rm = TRUE)))
}

# Obtener los l?mites Y para los gr?ficos
y_limits <- calculate_y_limits(list(
  calculate_accuracy_by_stimulus_and_group(DATA_before),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "M")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "F")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Condición == "A")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Condición == "S")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "M" & Condición == "A")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "M" & Condición == "S")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "F" & Condición == "A")),
  calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "F" & Condición == "S"))
))

# Definir la funci?n para generar gr?ficos de precisi?n con Wilcoxon y significancia y escalas comunes
generate_accuracy_plots_with_significance <- function(data, group_name, y_limits) {
  congruent_data <- data %>% filter(Stimulus == "Congruent")
  incongruent_data <- data %>% filter(Stimulus == "Incongruent")
  
  if (nrow(congruent_data) != nrow(incongruent_data)) {
    warning(paste("Skipping Wilcoxon test for", group_name, "due to unequal group sizes"))
    significance <- "ns"
  } else {
    wilcoxon_test <- wilcox.test(congruent_data$accuracy, incongruent_data$accuracy, paired = TRUE)
    significance <- ifelse(wilcoxon_test$p.value < 0.001, "***",
                           ifelse(wilcoxon_test$p.value < 0.01, "**",
                                  ifelse(wilcoxon_test$p.value < 0.05, "*", "ns")))
  }
  
  plot <- ggplot(data, aes(x = Stimulus, y = accuracy, fill = Stimulus)) +
    geom_boxplot() +
    geom_jitter(width = 0.2, alpha = 0.5) +
    labs(title = paste("Accuracy by Stimulus Type for", group_name),
         x = "Stimulus",
         y = "Accuracy") +
    theme_minimal() +
    ylim(y_limits) +
    geom_signif(comparisons = list(c("Congruent", "Incongruent")),
                annotations = significance,
                y_position = max(data$accuracy, na.rm = TRUE) + 0.05,
                tip_length = 0.01)
  
  return(plot)
}

# Generar gr?ficos de precisi?n por tipo de est?mulo y grupo con Wilcoxon y significancia
accuracy_stimulus_plots <- list(
  All = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before), "All", y_limits),
  Males = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "M")), "Males", y_limits),
  Females = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "F")), "Females", y_limits),
  Active = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Condición == "A")), "Active", y_limits),
  Sedentary = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Condición == "S")), "Sedentary", y_limits),
  Active_Males = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "M" & Condición == "A")), "Active Males", y_limits),
  Sedentary_Males = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "M" & Condición == "S")), "Sedentary Males", y_limits),
  Active_Females = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "F" & Condición == "A")), "Active Females", y_limits),
  Sedentary_Females = generate_accuracy_plots_with_significance(calculate_accuracy_by_stimulus_and_group(DATA_before %>% filter(Sexo == "F" & Condición == "S")), "Sedentary Females", y_limits)
)

# Agrupar y mostrar los gr?ficos en conjuntos de tres
accuracy_stimulus_groups <- list(
  group1 = list(accuracy_stimulus_plots$All, accuracy_stimulus_plots$Active, accuracy_stimulus_plots$Sedentary),
  group2 = list(accuracy_stimulus_plots$Males, accuracy_stimulus_plots$Active_Males, accuracy_stimulus_plots$Sedentary_Males),
  group3 = list(accuracy_stimulus_plots$Females, accuracy_stimulus_plots$Active_Females, accuracy_stimulus_plots$Sedentary_Females)
)

# Mostrar los gr?ficos agrupados
for (group in accuracy_stimulus_groups) {
  grid.arrange(grobs = group, ncol = 3)
}


#############AN?LISIS ESTAD?STICO#############

# Medias y Desviaciones Est?ndar por grupo
summary_stats <- DATA_before %>%
  group_by(Condition_Sex) %>%
  summarise(
    mean_rt = mean(rt, na.rm = TRUE),
    sd_rt = sd(rt, na.rm = TRUE),
    mean_accuracy = mean(acu, na.rm = TRUE),
    sd_accuracy = sd(acu, na.rm = TRUE)
  )

print(summary_stats)

# Histogramas
ggplot(DATA_before, aes(x = rt, fill = Condition_Sex)) +
  geom_histogram(binwidth = 50, position = "dodge") +
  labs(title = "Distribution of Reaction Time by Group", x = "Reaction Time", y = "Count")

# Boxplots
ggplot(DATA_before, aes(x = Condition_Sex, y = rt, fill = Condition_Sex)) +
  geom_boxplot() +
  labs(title = "Boxplot of Reaction Time by Group", x = "Group", y = "Reaction Time")

# Realizar las pruebas t de Student
t_test_F_vs_M <- t.test(rt ~ Sexo, data = DATA_before)
t_test_A_vs_S <- t.test(rt ~ Condición, data = DATA_before)
t_test_A_F_vs_A_M <- t.test(rt ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("A_F", "A_M")))
t_test_S_F_vs_S_M <- t.test(rt ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("S_F", "S_M")))
t_test_A_F_vs_S_F <- t.test(rt ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("A_F", "S_F")))
t_test_A_M_vs_S_M <- t.test(rt ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("A_M", "S_M")))

# Organizar los resultados en un data frame
results <- data.frame(
  Comparison = c("F vs M", "A vs S", "A_F vs A_M", "S_F vs S_M", "A_F vs S_F", "A_M vs S_M"),
  t_value = c(t_test_F_vs_M$statistic, t_test_A_vs_S$statistic, t_test_A_F_vs_A_M$statistic, t_test_S_F_vs_S_M$statistic, t_test_A_F_vs_S_F$statistic, t_test_A_M_vs_S_M$statistic),
  df = c(t_test_F_vs_M$parameter, t_test_A_vs_S$parameter, t_test_A_F_vs_A_M$parameter, t_test_S_F_vs_S_M$parameter, t_test_A_F_vs_S_F$parameter, t_test_A_M_vs_S_M$parameter),
  p_value = c(t_test_F_vs_M$p.value, t_test_A_vs_S$p.value, t_test_A_F_vs_A_M$p.value, t_test_S_F_vs_S_M$p.value, t_test_A_F_vs_S_F$p.value, t_test_A_M_vs_S_M$p.value),
  mean_group_1 = c(t_test_F_vs_M$estimate[1], t_test_A_vs_S$estimate[1], t_test_A_F_vs_A_M$estimate[1], t_test_S_F_vs_S_M$estimate[1], t_test_A_F_vs_S_F$estimate[1], t_test_A_M_vs_S_M$estimate[1]),
  mean_group_2 = c(t_test_F_vs_M$estimate[2], t_test_A_vs_S$estimate[2], t_test_A_F_vs_A_M$estimate[2], t_test_S_F_vs_S_M$estimate[2], t_test_A_F_vs_S_F$estimate[2], t_test_A_M_vs_S_M$estimate[2]),
  conf_interval_low = c(t_test_F_vs_M$conf.int[1], t_test_A_vs_S$conf.int[1], t_test_A_F_vs_A_M$conf.int[1], t_test_S_F_vs_S_M$conf.int[1], t_test_A_F_vs_S_F$conf.int[1], t_test_A_M_vs_S_M$conf.int[1]),
  conf_interval_high = c(t_test_F_vs_M$conf.int[2], t_test_A_vs_S$conf.int[2], t_test_A_F_vs_A_M$conf.int[2], t_test_S_F_vs_S_M$conf.int[2], t_test_A_F_vs_S_F$conf.int[2], t_test_A_M_vs_S_M$conf.int[2])
)

# Renombrar las columnas
colnames(results) <- c("Comparison", "t-value", "df", "p-value", "Mean Group 1", "Mean Group 2", "95% CI Low", "95% CI High")

# Crear la tabla elegante
results %>%
  mutate(`p-value` = formatC(`p-value`, format = "e", digits = 2)) %>%
  kbl(digits = 4, format = "html", caption = "Results of t-tests") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  add_header_above(c(" " = 1, "t-test Results" = 7)) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)


library(car)  # Para la funci?n Anova
library(dplyr)
library(kableExtra)

# Realizar los ANOVAs
anova_sexo <- Anova(lm(rt ~ Sexo, data = DATA_before), type = "III")
anova_condicion <- Anova(lm(rt ~ Condición, data = DATA_before), type = "III")
anova_condition_sex <- Anova(lm(rt ~ Condition_Sex, data = DATA_before), type = "III")

# Extraer los resultados del ANOVA
summary_sexo <- as.data.frame(anova_sexo)
summary_condicion <- as.data.frame(anova_condicion)
summary_condition_sex <- as.data.frame(anova_condition_sex)

# Organizar los resultados en un data frame
results_anova <- data.frame(
  Comparison = c("Sex", "Condition", "Condition_Sex"),
  F_value = c(summary_sexo$`F value`[1], summary_condicion$`F value`[1], summary_condition_sex$`F value`[1]),
  df1 = c(summary_sexo$Df[1], summary_condicion$Df[1], summary_condition_sex$Df[1]),
  df2 = c(summary_sexo$Df[2], summary_condicion$Df[2], summary_condition_sex$Df[2]),
  p_value = c(summary_sexo$`Pr(>F)`[1], summary_condicion$`Pr(>F)`[1], summary_condition_sex$`Pr(>F)`[1])
)

# Renombrar las columnas
colnames(results_anova) <- c("Comparison", "F-value", "df1", "df2", "p-value")

# Crear la tabla elegante
results_anova %>%
  mutate(`p-value` = formatC(`p-value`, format = "e", digits = 2)) %>%
  kbl(digits = 4, format = "html", caption = "Results of ANOVA") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  add_header_above(c(" " = 1, "ANOVA Results" = 4)) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)


# Pruebas t de Student para Accuracy
t_test_accuracy_F_vs_M <- t.test(acu ~ Sexo, data = DATA_before)
t_test_accuracy_A_vs_S <- t.test(acu ~ Condición, data = DATA_before)
t_test_accuracy_A_F_vs_A_M <- t.test(acu ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("A_F", "A_M")))
t_test_accuracy_S_F_vs_S_M <- t.test(acu ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("S_F", "S_M")))
t_test_accuracy_A_F_vs_S_F <- t.test(acu ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("A_F", "S_F")))
t_test_accuracy_A_M_vs_S_M <- t.test(acu ~ Condition_Sex, data = DATA_before %>% filter(Condition_Sex %in% c("A_M", "S_M")))

# Organizar los resultados en un data frame
results_t_test_accuracy <- data.frame(
  Comparison = c("F vs M", "A vs S", "A_F vs A_M", "S_F vs S_M", "A_F vs S_F", "A_M vs S_M"),
  t_value = c(t_test_accuracy_F_vs_M$statistic, t_test_accuracy_A_vs_S$statistic, t_test_accuracy_A_F_vs_A_M$statistic, t_test_accuracy_S_F_vs_S_M$statistic, t_test_accuracy_A_F_vs_S_F$statistic, t_test_accuracy_A_M_vs_S_M$statistic),
  df = c(t_test_accuracy_F_vs_M$parameter, t_test_accuracy_A_vs_S$parameter, t_test_accuracy_A_F_vs_A_M$parameter, t_test_accuracy_S_F_vs_S_M$parameter, t_test_accuracy_A_F_vs_S_F$parameter, t_test_accuracy_A_M_vs_S_M$parameter),
  p_value = c(t_test_accuracy_F_vs_M$p.value, t_test_accuracy_A_vs_S$p.value, t_test_accuracy_A_F_vs_A_M$p.value, t_test_accuracy_S_F_vs_S_M$p.value, t_test_accuracy_A_F_vs_S_F$p.value, t_test_accuracy_A_M_vs_S_M$p.value),
  mean_group_1 = c(t_test_accuracy_F_vs_M$estimate[1], t_test_accuracy_A_vs_S$estimate[1], t_test_accuracy_A_F_vs_A_M$estimate[1], t_test_accuracy_S_F_vs_S_M$estimate[1], t_test_accuracy_A_F_vs_S_F$estimate[1], t_test_accuracy_A_M_vs_S_M$estimate[1]),
  mean_group_2 = c(t_test_accuracy_F_vs_M$estimate[2], t_test_accuracy_A_vs_S$estimate[2], t_test_accuracy_A_F_vs_A_M$estimate[2], t_test_accuracy_S_F_vs_S_M$estimate[2], t_test_accuracy_A_F_vs_S_F$estimate[2], t_test_accuracy_A_M_vs_S_M$estimate[2]),
  conf_interval_low = c(t_test_accuracy_F_vs_M$conf.int[1], t_test_accuracy_A_vs_S$conf.int[1], t_test_accuracy_A_F_vs_A_M$conf.int[1], t_test_accuracy_S_F_vs_S_M$conf.int[1], t_test_accuracy_A_F_vs_S_F$conf.int[1], t_test_accuracy_A_M_vs_S_M$conf.int[1]),
  conf_interval_high = c(t_test_accuracy_F_vs_M$conf.int[2], t_test_accuracy_A_vs_S$conf.int[2], t_test_accuracy_A_F_vs_A_M$conf.int[2], t_test_accuracy_S_F_vs_S_M$conf.int[2], t_test_accuracy_A_F_vs_S_F$conf.int[2], t_test_accuracy_A_M_vs_S_M$conf.int[2])
)

# Renombrar las columnas
colnames(results_t_test_accuracy) <- c("Comparison", "t-value", "df", "p-value", "Mean Group 1", "Mean Group 2", "95% CI Low", "95% CI High")

# Crear la tabla elegante
results_t_test_accuracy %>%
  mutate(`p-value` = formatC(`p-value`, format = "e", digits = 2)) %>%
  kbl(digits = 4, format = "html", caption = "Results of t-tests for Accuracy") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  add_header_above(c(" " = 1, "t-test Results" = 7)) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)

# Realizar los ANOVAs para Accuracy
anova_accuracy_sexo <- Anova(lm(acu ~ Sexo, data = DATA_before), type = "III")
anova_accuracy_condicion <- Anova(lm(acu ~ Condición, data = DATA_before), type = "III")
anova_accuracy_condition_sex <- Anova(lm(acu ~ Condition_Sex, data = DATA_before), type = "III")

# Convertir resultados a data frames
summary_accuracy_sexo <- as.data.frame(anova_accuracy_sexo)
summary_accuracy_condicion <- as.data.frame(anova_accuracy_condicion)
summary_accuracy_condition_sex <- as.data.frame(anova_accuracy_condition_sex)

# Organizar los resultados en un data frame
results_anova_accuracy <- data.frame(
  Comparison = c("Sex", "Condition", "Condition_Sex"),
  F_value = c(summary_accuracy_sexo$`F value`[1], summary_accuracy_condicion$`F value`[1], summary_accuracy_condition_sex$`F value`[1]),
  df1 = c(summary_accuracy_sexo$Df[1], summary_accuracy_condicion$Df[1], summary_accuracy_condition_sex$Df[1]),
  df2 = c(summary_accuracy_sexo$Df[2], summary_accuracy_condicion$Df[2], summary_accuracy_condition_sex$Df[2]),
  p_value = c(summary_accuracy_sexo$`Pr(>F)`[1], summary_accuracy_condicion$`Pr(>F)`[1], summary_accuracy_condition_sex$`Pr(>F)`[1])
)

# Renombrar las columnas
colnames(results_anova_accuracy) <- c("Comparison", "F-value", "df1", "df2", "p-value")

# Crear la tabla elegante
results_anova_accuracy %>%
  mutate(`p-value` = formatC(`p-value`, format = "e", digits = 2)) %>%
  kbl(digits = 4, format = "html", caption = "Results of ANOVA for Accuracy") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  add_header_above(c(" " = 1, "ANOVA Results" = 4)) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)


# Ajustar modelos lineales generales para RT
glm_rt <- lm(rt ~ Sexo + Condición + Sexo * Condición, data = data_incongruente)
summary(glm_rt)

# Ajustar modelos lineales generales para Accuracy
glm_accuracy <- lm(acu ~ Sexo + Condición + Sexo * Condición, data = data_incongruente)
summary(glm_accuracy)

# Ajustar modelos lineales mixtos para RT (si fuera necesario)
lmm_rt <- lmer(rt ~ Sexo + Condición + (1|subID), data = DATA_before)
summary(lmm_rt)

# Ajustar modelos lineales mixtos para Accuracy (si fuera necesario)
lmm_accuracy <- lmer(acu ~ Sexo + Condición + (1|subID), data = DATA_before)
summary(lmm_accuracy)


# Ajustar modelos lineales mixtos para RT considerando ambos est?mulos
lmm_rt_general <- lmer(rt ~ Sexo + Condición + est + Sexo * Condición + (1|subID), data = DATA_before)
summary(lmm_rt_general)

# Ajustar modelos lineales mixtos para Accuracy considerando ambos est?mulos
lmm_accuracy_general <- lmer(acu ~ Sexo + Condición + est + Sexo * Condición + (1|subID), data = DATA_before)
summary(lmm_accuracy_general)

# Filtrar los datos para el est?mulo incongruente
data_incongruente <- DATA_before %>% filter(est == 12)

# Ajustar modelos lineales mixtos para RT espec?fico para est?mulo incongruente
lmm_rt_incongruente <- lmer(rt ~ Sexo + Condición + (1|subID), data = data_incongruente)
summary(lmm_rt_incongruente)

# Ajustar modelos lineales mixtos para Accuracy espec?fico para est?mulo incongruente
lmm_accuracy_incongruente <- lmer(acu ~ Sexo + Condición + (1|subID), data = data_incongruente)
summary(lmm_accuracy_incongruente)


#####MODELOS RESUMEN######3

lmm_rt_general <- lmer(rt ~ Sexo + Condición + est + Sexo * Condición + (1|subID), data = DATA_before)
summary(lmm_rt_general)

lmm_accuracy_general <- lmer(acu ~ Sexo + Condición + est + Sexo * Condición + (1|subID), data = DATA_before)
summary(lmm_accuracy_general)

data_congruente <- DATA_before %>% filter(est == 11)

lmm_rt_congruente <- lmer(rt ~ Sexo + Condición + (1|subID), data = data_congruente)
summary(lmm_rt_congruente)

data_incongruente <- DATA_before %>% filter(est == 12)
lmm_rt_incongruente <- lmer(rt ~ Sexo + Condición + (1|subID), data = data_incongruente)
summary(lmm_rt_incongruente)
lmm_accuracy_incongruente <- lmer(acu ~ Sexo + Condición + (1|subID), data = data_incongruente)
summary(lmm_accuracy_incongruente)

# Crear una funci?n para extraer los resultados del modelo
extract_model_results <- function(model, model_name) {
  summary_model <- summary(model)
  fixed_effects <- summary_model$coefficients
  
  # Verificar si existen columnas de p-valor en los efectos fijos
  p_value_col <- if ("Pr(>|t|)" %in% colnames(fixed_effects)) {
    "Pr(>|t|)"
  } else if ("Pr(>|z|)" %in% colnames(fixed_effects)) {
    "Pr(>|z|)"
  } else if ("p.value" %in% colnames(fixed_effects)) {
    "p.value"
  } else {
    NA
  }
  
  if (is.na(p_value_col)) {
    warning("No se encontr? la columna de p-valor en los efectos fijos. Usando NA para p-values.")
    p_values <- rep(NA, nrow(fixed_effects))
  } else {
    p_values <- formatC(fixed_effects[, p_value_col], format = "e", digits = 2)
  }
  
  return(data.frame(
    Model = model_name,
    Estimate = fixed_effects[, "Estimate"],
    Std_Error = fixed_effects[, "Std. Error"],
    t_value = fixed_effects[, "t value"],
    p_value = p_values
  ))
}


# Extraer resultados de los modelos
results_rt_general <- extract_model_results(lmm_rt_general, "RT General")
results_accuracy_general <- extract_model_results(lmm_accuracy_general, "Accuracy General")
results_rt_congruente <- extract_model_results(lmm_rt_congruente, "RT Congruente")
results_accuracy_congruente <- extract_model_results(lmm_accuracy_congruente, "Accuracy Congruente")
results_rt_incongruente <- extract_model_results(lmm_rt_incongruente, "RT Incongruente")
results_accuracy_incongruente <- extract_model_results(lmm_accuracy_incongruente, "Accuracy Incongruente")

# Combinar todos los resultados en un solo data frame
all_results <- rbind(results_rt_general, results_accuracy_general, results_rt_congruente, results_accuracy_congruente, results_rt_incongruente, results_accuracy_incongruente)

# Crear la tabla elegante
all_results %>%
  kbl(digits = 4, format = "html", caption = "Summary of Linear Mixed Models") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  add_header_above(c(" " = 1, "Model Results" = 4)) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE)

library(lme4)
modelo_mixto_rt <- lmer(rt ~ Sexo * Condición + (1 | subID), data = data_incongruente)
summary(modelo_mixto)

modelo_mixto_accu <- lmer(acu ~ Sexo * Condición + (1 | subID), data = data_incongruente)
summary(modelo_mixto_accu)

